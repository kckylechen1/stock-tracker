# Stock Agent 架构设计 - 参考 Claude Code / opencode

> 目标：构建一个类似 Claude Code 的 Agent 架构，作为 Chatbot 的智能后端，结合现有的 Memory 和 Tools 系统。

---

## 🎯 为什么需要新架构？

### 当前问题

| 问题         | 现状                       | 期望                                  |
| ------------ | -------------------------- | ------------------------------------- |
| 工具调用能力 | 单轮调用，模型判断不够智能 | 多轮 ReAct 循环，自动判断需要哪些数据 |
| 上下文管理   | 每次对话独立               | 保持对话历史，累积工具结果            |
| 错误处理     | 工具失败就失败             | 自动重试、降级、换方案                |
| 回答质量     | 信息不全也硬给建议         | 确保数据充分再给结论                  |

### 对比：直接 API vs Agent 架构

```
直接调用 API：
用户 → API → 模型 → 回答（可能信息不全）

Agent 架构：
用户 → Agent → [思考] → [调用工具] → [验证] → [再思考] → [再调用] → 回答（信息充分）
```

---

## 🏗️ 架构设计

### 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Stock Agent Core                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   ┌───────────────────────────────────────────────────────────────┐     │
│   │                     ReAct Loop (核心循环)                       │     │
│   │  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐        │     │
│   │  │ Reason  │──▶│   Act   │──▶│ Observe │──▶│ Reflect │──┐     │     │
│   │  │ (推理)   │   │ (行动)   │   │ (观察)   │   │ (反思)   │  │     │     │
│   │  └─────────┘   └─────────┘   └─────────┘   └─────────┘  │     │     │
│   │       ▲                                                  │     │     │
│   │       └──────────────────────────────────────────────────┘     │     │
│   └───────────────────────────────────────────────────────────────┘     │
│                                    │                                     │
│                                    ▼                                     │
│   ┌────────────────┐   ┌────────────────┐   ┌────────────────┐         │
│   │  Tool Manager  │   │ Memory Manager │   │ Context Manager│         │
│   │   (工具管理)    │   │   (记忆管理)    │   │   (上下文管理)  │         │
│   └────────────────┘   └────────────────┘   └────────────────┘         │
│           │                    │                    │                    │
├───────────┴────────────────────┴────────────────────┴───────────────────┤
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                         Tools Layer (工具层)                         │ │
│  ├───────────┬───────────┬───────────┬───────────┬───────────────────┤ │
│  │ Technical │  Fund     │  Market   │  Memory   │     AKShare       │ │
│  │ Analysis  │  Flow     │  Status   │  Tools    │     Dynamic       │ │
│  └───────────┴───────────┴───────────┴───────────┴───────────────────┘ │
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐ │
│  │                        Memory Layer (记忆层)                         │ │
│  ├───────────┬───────────┬───────────┬───────────────────────────────┤ │
│  │ Positions │  Trades   │  Lessons  │     User Profile              │ │
│  │  (持仓)    │  (交易)   │  (教训)    │      (用户画像)                │ │
│  └───────────┴───────────┴───────────┴───────────────────────────────┘ │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 核心组件

| 组件                | 职责                                      | 对应现有代码            |
| ------------------- | ----------------------------------------- | ----------------------- |
| **ReAct Loop**      | 推理-行动循环，决定何时调用工具、何时回答 | 新建 `stockAgent.ts`    |
| **Tool Manager**    | 管理所有工具，执行工具调用，处理失败      | 现有 `stockTools.ts`    |
| **Memory Manager**  | 管理交易记忆，生成上下文                  | 现有 `tradingMemory.ts` |
| **Context Manager** | 管理对话历史，累积工具结果                | 新建                    |

---

## 📋 ReAct 循环详解

### 什么是 ReAct？

ReAct = **Re**asoning + **Act**ing，是一种让 LLM 交替进行推理和行动的框架。

### 循环流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    ReAct Loop 执行流程                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 用户提问: "分析一下中际旭创能不能买"                           │
│                          ↓                                       │
│  2. REASON (推理):                                               │
│     "要回答这个问题，我需要：                                      │
│      - 技术分析数据（均线、MACD）                                  │
│      - 资金流向（主力是否在买）                                    │
│      - 大盘环境（是否配合）                                        │
│      - 用户是否有这只股票的历史教训"                               │
│                          ↓                                       │
│  3. ACT (行动):                                                  │
│     调用工具: analyze_stock_technical, get_fund_flow,            │
│              get_market_status, get_trading_memory               │
│                          ↓                                       │
│  4. OBSERVE (观察):                                              │
│     "技术分析显示: 2/5 分（走弱）                                  │
│      资金流向显示: 主力净流出 82 亿                                │
│      大盘环境: 温和上涨"                                          │
│                          ↓                                       │
│  5. REFLECT (反思):                                              │
│     "数据完整了吗？✓                                              │
│      需要更多信息吗？不需要                                        │
│      可以给出结论了"                                              │
│                          ↓                                       │
│  6. 最终回答:                                                    │
│     【结论】建议卖出                                              │
│     【理由】技术面走弱(2/5)，资金持续流出，个股无力跟涨大盘          │
│     【操作】583 元附近出清，止损 580 元                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 多轮循环示例

```
迭代 1:
  Reason: 需要技术分析
  Act: 调用 analyze_stock_technical
  Observe: 数据获取成功
  Reflect: 还需要资金面数据 → 继续

迭代 2:
  Reason: 需要资金流向
  Act: 调用 get_fund_flow
  Observe: 主力净流出
  Reflect: 还需要大盘环境 → 继续

迭代 3:
  Reason: 需要大盘状态
  Act: 调用 get_market_status
  Observe: 大盘温和上涨
  Reflect: 数据足够了 → 生成回答

最终: 综合所有数据，生成投资建议
```

---

## 🔧 与现有系统集成

### 1. Trading Memory 集成

```typescript
// 在每次分析前，自动加载用户的交易记忆
const context = tradingMemory.generateAIContext(stockCode);

// 注入到 System Prompt
systemPrompt += `\n\n${context}`;
```

已有的 Memory 数据结构：

- `Position` - 当前持仓
- `Trade` - 交易历史
- `TradingLesson` - 交易教训
- `UserProfile` - 用户偏好

### 2. Stock Tools 集成

现有工具（直接复用）：
| 类别 | 工具 |
|------|------|
| 技术分析 | `analyze_stock_technical`, `analyze_minute_patterns` |
| 资金面 | `get_fund_flow`, `get_fund_flow_history`, `get_fund_flow_rank` |
| 大盘环境 | `get_market_status`, `get_market_fund_flow` |
| 市场数据 | `get_stock_quote`, `get_kline_data`, `get_zt_pool`, `get_concept_board` |
| 记忆系统 | `get_trading_memory`, `add_trading_lesson` |
| 动态调用 | `call_akshare` |

### 3. 现有 grokAgent.ts 的问题

```typescript
// 当前架构：Grok + Qwen3 主从
// 问题：Grok 只能 delegate 给 Qwen，不能直接调用工具

// 新架构：统一的 ReAct Agent
// 改进：直接让 Grok 调用工具，循环执行直到满意
```

---

## 📝 实现计划

### Phase 1: 核心 Agent（1-2天）

| 任务 | 文件              | 说明                             |
| ---- | ----------------- | -------------------------------- |
| 1.1  | `stockAgent.ts`   | ReAct 循环核心逻辑 ✅ 已创建框架 |
| 1.2  | `agentPrompts.ts` | Agent 专用提示词                 |
| 1.3  | `agentContext.ts` | 对话历史和上下文管理             |

### Phase 2: 工具增强（1天）

| 任务 | 文件               | 说明                   |
| ---- | ------------------ | ---------------------- |
| 2.1  | `stockTools.ts`    | 增加工具失败处理和重试 |
| 2.2  | `toolValidator.ts` | 验证工具结果是否完整   |

### Phase 3: Memory 深度集成（1天）

| 任务 | 文件               | 说明                     |
| ---- | ------------------ | ------------------------ |
| 3.1  | `tradingMemory.ts` | 增加自动学习能力         |
| 3.2  | `lessonMatcher.ts` | 基于信号模式匹配历史教训 |

### Phase 4: API 和前端集成（1天）

| 任务 | 文件              | 说明                |
| ---- | ----------------- | ------------------- |
| 4.1  | `routers.ts`      | 新增 Agent API 路由 |
| 4.2  | `AIChatPanel.tsx` | 前端对接新 Agent    |

---

## 🔄 新旧架构对比

### 当前架构 (grokAgent.ts)

```
用户 → Grok → delegate_to_qwen → Qwen3 调用工具 → 结果返回 Grok → 回答
```

**问题**：

- 两层调用，延迟高
- Grok 不能直接看到工具结果
- 没有多轮循环验证

### 新架构 (stockAgent.ts)

```
用户 → Agent Loop → Grok 直接调用工具 → 验证数据 → (循环) → 回答
```

**改进**：

- 单层调用，更快
- Grok 直接看到工具结果
- 多轮循环确保数据充分

---

## 🧪 测试计划

### 测试场景

1. **单股票分析**
   - 输入："分析一下中际旭创能不能买"
   - 期望：调用技术分析+资金+大盘，给出完整建议

2. **多股票对比**
   - 输入："中际旭创和光迅科技哪个更值得买"
   - 期望：分别分析两只股票，对比后给出建议

3. **错误处理**
   - 输入：一个不存在的股票代码
   - 期望：优雅提示，不崩溃

4. **记忆应用**
   - 输入：分析用户曾经交易过并有教训的股票
   - 期望：自动提醒相关教训

---

## 📚 参考资料

### Claude Code / opencode 核心理念

1. **ReAct 框架** - 推理与行动交替
2. **工具优先** - 先获取数据再分析
3. **自我纠错** - 检测错误并重试
4. **上下文累积** - 保持对话连贯性

### Anthropic Tool Use 最佳实践

1. **Tool Runner** - 自动管理工具调用循环
2. **Strict Tool Use** - 保证工具参数格式正确
3. **Extended Thinking** - 在思考过程中调用工具

---

## ⚡ 快速开始

### 测试新 Agent

```bash
# 已创建的 stockAgent.ts
npx tsx -e "
import 'dotenv/config';
import { StockAgent } from './server/_core/stockAgent';

const agent = new StockAgent({ verbose: true });
agent.chat('分析一下中际旭创能不能买').then(console.log);
"
```

### 后续开发重点

1. **完善 ReAct 提示词** - 让模型更好地理解何时该调用工具
2. **增加数据验证** - 确保工具返回的数据完整
3. **前端流式展示** - 实时显示思考过程和工具调用

---

## 🎯 预期效果

| 指标           | 当前     | 目标       |
| -------------- | -------- | ---------- |
| 回答准确性     | 70%      | 90%+       |
| 工具调用命中率 | 80%      | 95%+       |
| 用户满意度     | 一般     | 高         |
| 响应时间       | 快但不准 | 稍慢但准确 |

---

**创建时间**: 2026-01-11
**状态**: 计划阶段
